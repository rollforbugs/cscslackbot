from __future__ import unicode_literals

import math
import re


"""Matches decimals of the form 'x.y' or '.z'"""
DECIMAL_RE = re.compile(r'^([0-9]+(\.[0-9]+)?|\.[0-9]+)$')


def clamp(x, lower, upper):
    """
    Clamps a comparable value to a range. Intended for numbers
    but should work for any type that implements `>` and `<`.

    Args:
        x (T): value to be clamped
        lower (T): min value for x
        upper (T): max value for x

    Returns:
        (T) x clamped.

    """
    return lower if x < lower else upper if x > upper else x


def to_human_readable(n, iec=True):
    """
    Creates a human-readable string for a number that uses SI or IEC binary
    suffixes (k/Ki, M/Mi, G/Gi, ...).  This is similar to the -h flag on *nix
    tools like ls and df.

    Args:
        n (int): number to make human readable
        iec (bool): whether to use IEC binary (2^10) units
    
    Returns:
        int: a human-readable string for the number to one decimal place
    """
    if iec:
        suffixes = ('', 'Ki', 'Mi', 'Gi', 'Ti', 'Pi', 'Ei', 'Zi', 'Yi')
        base = 1024
    else:
        suffixes = ('', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
        base = 1000

    exp = math.floor(math.log(n, base))
    n = round(n / (base ** exp), 1)

    return str(n) + suffixes[exp]


def from_human_readable(s, assume_iec=False):
    """
    Parses a human-readable string for a number that uses SI or IEC binary
    suffixes (k/Ki, M/Mi, G/Gi, ...), like the ones generated by the -h flag on
    *nix tools like ls and df.
    
    If the string ends in 'B', 'b', or 'o', as if it represents the size of
    some data in bytes, bits, or octets, that character is stripped off before
    parsing.

    Args:
        s (str): number to parse
        assume_iec (bool): assume IEC binary (2^10) units even if there is no 'i'

    Returns:
        int: the parsed number
    
    Raises:
        ValueError: if `s` cannot be parsed as a valid decimal with suffix
    """
    if s[-1] in ('B', 'b', 'o'):
        s = s[:-1]

    # Check for IEC units and choose the correct base
    base = 1000
    if s[-1] in ('i', 'I'):
        s = s[:-1]
        base = 1024
    elif assume_iec:
        base = 1024

    # Check for a valid suffix
    exp = 0
    suffixes = ('', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')
    if s[-1].isalpha():
        suffix = s[-1].upper()
        if suffix in suffixes:
            s = s[:-1]
            exp = suffixes.index(suffix)
        else:
            raise ValueError('Not a valid SI/IEC suffix: {}'.format(suffix))

    # Validate and try to parse the string
    if DECIMAL_RE.match(s):
        n = float(s)
        n = n * base ** exp
    else:
        raise ValueError('Could not parse decimal value: {}'.format(s))

    return n
